// new module script

#define MAX_OVERLAYS 8192
Overlay* overlayPool[MAX_OVERLAYS];
bool overlayUsed[MAX_OVERLAYS];
int lastUsed;

#define MAX_LERP 1024
#define INT_FRAC 1024

// lerp from percent 0 to 1024
int _Lerp(int start, int end, int percent) {
  if (percent < 0) percent = 0;
  if (percent > MAX_LERP) percent = MAX_LERP;

  // Calculate the interpolated value
  return start + ((end - start) * percent) / MAX_LERP;
}

int InvalidateOverlay(int index)
{
  if(overlayPool[index] != null)
    overlayPool[index].Remove();
  overlayPool[index] = null; // Clear the reference to the overlay
  overlayUsed[index] = false; // Mark the overlay slot as free
  return -1;
}

// Find an available overlay slot in the pool
function GetAvailableOverlayIndex() {
  for (int i = lastUsed; i < MAX_OVERLAYS; i++) {
    if (!overlayUsed[i]) {
      InvalidateOverlay(i);
      overlayUsed[i] = true;
      lastUsed = i;
      return i;
    }
  }
  for (int i = 0; (i < lastUsed) && (i < MAX_OVERLAYS); i++) {
    if (!overlayUsed[i]) {
      InvalidateOverlay(i);
      overlayUsed[i] = true;
      lastUsed = i;
      return i;
    }
  }
  return -1; // No available overlay
}

void UpdateOverlayFromParticle(Overlay* ovr, Particle* p)
{
  ovr.X = (p.x/INT_FRAC);
  ovr.Y = (p.y/INT_FRAC);
  ovr.Transparency = p.transparency;
  ovr.Width = p.width;
  ovr.Height = p.height;
}

void Particle::Init(ParticleDefinition* def, int x, int y,  int overlayIndex) {
  if(this.overlayIndex >= 0 && this.overlayIndex < MAX_OVERLAYS) {
    InvalidateOverlay(this.overlayIndex);
  }

  this.x = INT_FRAC*(x + def.offsetX); // Offset based on emitter
  this.y = INT_FRAC*(y + def.offsetY); // Offset based on emitter
  this.life = def.life;
  this.vx = (def.vx*INT_FRAC)/1000;
  this.vy = (def.vy*INT_FRAC)/1000;
  this.gravity = (def.gravity*INT_FRAC)/1000;
  this.transparency = def.initialTransparency;
  this.initialTransparency = def.initialTransparency;
  this.finalTransparency = def.finalTransparency;
  this.width = def.initialWidth;
  this.initialWidth = def.initialWidth;
  this.finalWidth = def.finalWidth;
  this.height = def.initialHeight;
  this.initialHeight = def.initialHeight;
  this.finalHeight = def.finalHeight;
  this.overlayIndex = overlayIndex;
  this.initialLife = def.life; // Store initial life for transitions
  this.bounces = def.groundHitBounces;
  this.groundY = def.groundY;
  this.groundX = def.groundX;
  this.groundWidth = def.groundWidth;
  if(this.groundY > 0) {
    if(this.groundWidth <= 0 ) {
      this.groundWidth = 8192;
      this.groundX = -1024;
    }
  } else {
    this.groundY = 0;
    this.groundX = 0;
    this.groundWidth = 0;
  }

  if (overlayIndex >= 0 && overlayPool[overlayIndex] != null) {
    UpdateOverlayFromParticle(overlayPool[overlayIndex], this);
  }
}

bool Particle::IsAlive() {
  return (this.life > 0);
}

// Update the particle state and sync with overlay
void Particle::Update() {
  if (this.IsAlive()) {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += this.gravity; // Apply gravity
    this.life--;
    int px = this.x/INT_FRAC;
    int py = this.y/INT_FRAC;

    // Calculate the scaling and transparency transitions based on life
    int lifeRatio =  MAX_LERP - ((this.life * MAX_LERP) / this.initialLife); // 0 to 1024
    this.transparency = _Lerp(this.initialTransparency, this.finalTransparency, lifeRatio);
    this.width = _Lerp(this.initialWidth, this.finalWidth, lifeRatio);
    this.height = _Lerp(this.initialHeight, this.finalHeight, lifeRatio);

    if (this.overlayIndex >= 0 && overlayPool[this.overlayIndex] != null) {
      UpdateOverlayFromParticle(overlayPool[this.overlayIndex], this);
    }    
    
    if ((py >= this.groundY) && (px >= this.groundX) && (px <= (this.groundX + this.groundWidth))) {
      if (this.bounces) {
        this.vy = -(this.vy * 700)/INT_FRAC; // Invert velocity, reduce it to simulate energy loss
      } else {
        this.life = 0; // Mark particle as dead
      }
    }
  } else {
    // Remove overlay if life is over
    if (this.overlayIndex >= 0) {
      this.overlayIndex = InvalidateOverlay(this.overlayIndex); // Invalidate the overlay index
    }
  }
}

void Emitter::SetPosition(int x, int y)
{
  this.x = x;
  this.y = y;
}

void Emitter::SetParticleDefinitions(ParticleDefinition* definitions[], int definitionsCount)
{
  this.definitions = definitions;
  this.definitionsCount = definitionsCount;
}

// Initialize the emitter with position, particle definitions, and specific parameters
void Emitter::Init(int x, int y, ParticleDefinition* definitions[], int definitionsCount, int emitParticleCount, int particleCount) {
  this.SetPosition(x, y);
  this.particleCount = particleCount;
  this.SetParticleDefinitions(definitions, definitionsCount);
  this.emitParticleCount = emitParticleCount;
  this.particles = new Particle[particleCount];
  for (int i = 0; i < particleCount; i++) {
    this.particles[i] = new Particle;
  }
}

protected bool Emitter::EmitParticleIndex(int i)
{
  if(this.particles[i].IsAlive())
    return false;

  this.lastEmittedParticle = i;
  
  // Reuse dead particle if it's not alive anymore
  int overlayIndex = GetAvailableOverlayIndex();
  if (overlayIndex >= 0) {      
    // Randomly select a particle definition from the available definitions
    int defIndex = 0;
    if(this.definitionsCount > 0) {
      defIndex = Random(this.definitionsCount-1);
    }
    ParticleDefinition* def = this.definitions[defIndex];
    
    Overlay* ovr = Overlay.CreateGraphical(this.x, this.y, def.sprite);
    overlayPool[overlayIndex] = ovr;
    this.particles[i].Init(def, this.x, this.y, overlayIndex);
  }
  return true;
}

// Emit a single particle from the emitter
protected void Emitter::EmitSingleParticle() {
  //System.Log(eLogInfo, ">>begin sp");
  int i = this.lastEmittedParticle + 1;
  if(i >= this.particleCount)
    i = 0;
  if(this.EmitParticleIndex(i))
    return;
  
  //System.Log(eLogInfo, "loop1 sp");
  int loop_at = i;
  for (; i < this.particleCount; i++) {
    if (!this.particles[i].IsAlive())
    {
      this.EmitParticleIndex(i);
      return;
    }
  }
  
  //System.Log(eLogInfo, "loop2 sp");
  for (i=0; i < loop_at; i++) {
    if (!this.particles[i].IsAlive())
    {
      this.EmitParticleIndex(i);
      return;
    }
  }
  
  // FIX-ME: if we get here we need to do some sort of cooldown 
  // the issue is we are emitting too many particles per total particle count
  // along with particles that have a too big life
  //System.Log(eLogInfo, "<<end sp");
}

// Emit particles from the emitter
void Emitter::Emit() {
  for (int i = 0; i < this.emitParticleCount; i++) {
    this.EmitSingleParticle();
  }
}

// Update all particles
void Emitter::Update() {
  //int aliveParticles = 0;
  for (int i = 0; i < this.particleCount; i++) {
    if (this.particles[i].IsAlive()) {
      //aliveParticles++;
      this.particles[i].Update();
    } else if (this.particles[i].overlayIndex >= 0) {
      // Ensure overlays are freed for dead particles
      this.particles[i].overlayIndex = InvalidateOverlay(this.particles[i].overlayIndex); // Invalidate the overlay index
    }
  }
  //System.Log(eLogInfo, "ALIVE %d", aliveParticles);
}

void ContinuousEmitter::StartEmitting(int emitRate)
{
  if(emitRate < 4) emitRate = 4;
  this.emitRate = emitRate;
  this.isEmitting = true;
}

void ContinuousEmitter::StopEmitting()
{
  this.isEmitting = false; 
}

void ContinuousEmitter::UpdateContinuous()
{
  this.Update();
  if(this.isEmitting) {
    this._emitRateFrame--;
    
    if(this._emitRateFrame <= 0) {
      this._emitRateFrame = this.emitRate;
      this.Emit();
    }
  } 
}
  
ContinuousEmitter GPE;
export GPE;

void game_start()
{
  ParticleDefinition* d[];
  GPE.Init(Screen.Width/2, Screen.Height/2, d, 0, MAX_OVERLAYS/20, MAX_OVERLAYS);
}

void repeatedly_execute_always()
{
  GPE.UpdateContinuous();
}
