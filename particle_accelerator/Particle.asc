// new module script

#define MAX_LERP 1024
#define INT_FRAC 1024
#define MAX_OVERLAYS 2048
Overlay *overlayPool[MAX_OVERLAYS];
bool overlayUsed[MAX_OVERLAYS];
int lastUsed;

int FreeOverlay (int index)
{
  if (overlayPool[index] != null)
  {
    overlayPool[index].Transparency = 100;
  }
  overlayUsed[index] = false; // Mark the overlay slot as free
  return -1;
}

// Find an available overlay slot in the pool, remember the slot to speed up search
int FindFreeOverlaySlot ()
{
  for (int i = lastUsed + 1; i < MAX_OVERLAYS; i++)
  {
    if (!overlayUsed[i])
    {
      overlayUsed[i] = true;
      lastUsed = i;
      return i;
    }
  }
  for (int i = 0; i < lastUsed; i++)
  {
    if (!overlayUsed[i])
    {
      overlayUsed[i] = true;
      lastUsed = i;
      return i;
    }
  }
  return -1; // No available overlay
}

void SyncParticleOverlay (Overlay *ovr, Particle *p)
{
  ovr.Transparency = p.Transparency;
  ovr.Graphic = p.Sprite;
#ifdef SCRIPT_API_v362
  ovr.SetPosition (p.X, p.Y, p.Width, p.Height);
#else
  ovr.X = p.X;
  ovr.Y = p.Y;
  ovr.Width = p.Width;
  ovr.Height = p.Height;
#endif
#ifdef SCRIPT_API_v400
  ovr.Rotation = p.Angle;
#endif
}

// ---------------------- Particle methods ----------------------------

bool Particle::IsAlive ()
{
  return (this.life > 0);
}

bool Particle::HitsPoint (int x, int y)
{
  return (x >= this.X) && (y >= this.Y)
         && (x <= this.X + this.Width) && (y <= this.Y + this.Height);
}

bool Particle::HitsRect (int x, int y, int width, int height)
{
  return (x + height >= this.X) && (y + width >= this.Y)
         && (x <= this.X + this.Width) && (y <= this.Y + this.Height);
}

void Particle::_Init (ParticleDefinition *def, int x, int y, Overlay* ovr)
{
  this.mx = INT_FRAC * (x + def.OffsetX); // Offset based on emitter
  this.my = INT_FRAC * (y + def.OffsetY); // Offset based on emitter
  this.X = this.mx / INT_FRAC;
  this.Y = this.my / INT_FRAC;
  this.life = def.life;
  this.VelX = (def.VelX * INT_FRAC) / 1000;
  this.VelY = (def.VelY * INT_FRAC) / 1000;
  this.Gravity = (def.Gravity * INT_FRAC) / 1000;

  this.Transparency = def.TransparencyBegin;
  this.TransparencyBegin = def.TransparencyBegin;
  this.TransparencyDelta = def.TransparencyEnd - def.TransparencyBegin;

  this.Width = def.WidthBegin;
  this.WidthBegin = def.WidthBegin;
  this.WidthDelta = def.WidthEnd - def.WidthBegin;

  this.Height = def.HeightBegin;
  this.HeightBegin = def.HeightBegin;
  this.HeightDelta = def.HeightEnd - def.HeightBegin;

  this.rollSprite = def.Sprite - def.SpriteBegin;
  this.Sprite = def.Sprite;
  this.SpriteBegin = def.SpriteBegin;
  this.SpriteDelta = def.SpriteEnd - def.SpriteBegin;
  
#ifdef SCRIPT_API_v400
  this.RotationSpeed = def.RotationSpeed;
  this.Angle = def.Angle;
#endif

  this.initialLife = def.life; // Store initial life for transitions
  this.Bounces = def.Bounces;
  this.GroundY = def.GroundY;
  if (this.GroundY <= 0)
  {
    this.GroundY = 16777216; // a big number so it is not reached
  }
  
#ifdef SCRIPT_API_v400
  ovr.BlendMode = def.BlendMode;
#endif
  SyncParticleOverlay (ovr, this);
}

// Update the particle state and sync with overlay
void Particle::_Update ()
{
  // alive check is done before calling this function
  this.mx += this.VelX;
  this.my += this.VelY;
  this.VelY += this.Gravity; // Apply Gravity
  this.X = this.mx / INT_FRAC;
  this.Y = this.my / INT_FRAC;

  // Calculate the scaling and Transparency transitions based on life
  int percent = MAX_LERP - ((this.life * MAX_LERP) / this.initialLife); // 0 to 1024
  this.Transparency = this.TransparencyBegin + ((this.TransparencyDelta) * percent) / MAX_LERP;
  this.Width = this.WidthBegin + ((this.WidthDelta) * percent) / MAX_LERP;
  this.Height = this.HeightBegin + ((this.HeightDelta) * percent) / MAX_LERP;
  if (this.SpriteDelta > 0)
  {
    this.Sprite
        = this.SpriteBegin
          + (this.rollSprite + ((this.SpriteDelta) * percent) / MAX_LERP)
                % this.SpriteDelta;
  }
  
#ifdef SCRIPT_API_v400
  this.Angle += this.RotationSpeed;
  if (this.Angle >= 360.0)
    this.Angle -= 360.0;
  if (this.Angle < 0.0)
    this.Angle += 360.0;
#endif

  int oidx = this.overlayIndex;
  if (oidx >= 0 && overlayPool[oidx] != null)
  {
    Overlay *ovr = overlayPool[oidx];
    ovr.Transparency = this.Transparency;
    ovr.Graphic = this.Sprite;
#ifdef SCRIPT_API_v362
    ovr.SetPosition (this.X, this.Y, this.Width, this.Height);
#else
    ovr.X = this.X;
    ovr.Y = this.Y;
    ovr.Width = this.Width;
    ovr.Height = this.Height;
#endif
#ifdef SCRIPT_API_v400
    ovr.Rotation = this.Angle;
#endif
  }

  this.life--;

  if (this.Y >= this.GroundY)
  {
    if (this.Bounces)
    {
      this.VelY = -(this.VelY * 700) / INT_FRAC; // Invert velocity and simulate energy loss
    }
    else
    {
      this.life = 0; // Mark particle as dead (cheaper than other things...)
    }
  }
}


// ---------------------- Emitter methods ----------------------------

void Emitter::SetPosition (int x, int y)
{
  this.X = x;
  this.Y = y;
}

void Emitter::SetParticleDefinitions (ParticleDefinition *defs[], int defCount)
{
  for (int i = 0; i < defCount; i++)
  {
    ParticleDefinition *def = defs[i];
    if (def.SpriteBegin == 0 && def.SpriteEnd == 0)
    {
      def.SpriteBegin = def.Sprite;
      def.SpriteEnd = def.Sprite;
    }
  }

  this.definitions = defs;
  this.definitionsCount = defCount;
}

// Initialize the emitter with position, particle definitions, and other parameters
void Emitter::Init (int x, int y, ParticleDefinition *defs[], int defCount, int emitCount, int maxParticles)
{
  this.SetPosition (x, y);
  this.maxParticles = maxParticles;
  this.SetParticleDefinitions (defs, defCount);
  this.emitCount = emitCount;
  this.particles = new Particle[maxParticles];
  for (int i = 0; i < maxParticles; i++)
  {
    this.particles[i] = new Particle;
  }
}

// returns TRUE if it emitted the particle SUCCESSFULLY
protected bool Emitter::EmitParticleIndex (int i)
{
  Particle *p = this.particles[i];
  if (p.IsAlive ())
    return false;
    
  // Reuse dead particle if it's not alive anymore

  this.lastEmittedParticle = i; // remember to speed up loop for looking new particles
  int overlayIndex = FindFreeOverlaySlot ();
  if (overlayIndex >= 0)
  {
    // Randomly select a particle definition from the available definitions
    int defIndex = 0;
    if (this.definitionsCount > 0)
    {
      defIndex = Random (this.definitionsCount - 1);
    }
    ParticleDefinition *def = this.definitions[defIndex];

    if(p.overlayIndex >= 0) {
      FreeOverlay(p.overlayIndex);
    }
    if (overlayPool[overlayIndex] == null)
    {
      Overlay *ovr = Overlay.CreateGraphical (this.X, this.Y, def.Sprite);
      overlayPool[overlayIndex] = ovr;
    }
    p._Init (def, this.X, this.Y, overlayPool[overlayIndex]);
    p.overlayIndex = overlayIndex;
    return true;
  }
  return false;
}

// Emit a single particle from the emitter, returns TRUE for FAILURE
protected bool Emitter::EmitSingleParticle ()
{
  int i = (this.lastEmittedParticle + 1) % this.maxParticles;

  if (this.EmitParticleIndex (i)) // if it fail to emit, try to find a dead particle to reuse
    return false;

  int loop_at = i;
  for (; i < this.maxParticles; i++)
  {
    if (!this.particles[i].IsAlive ())
    {
      return !this.EmitParticleIndex (i);
    }
  }

  for (i = 0; i < loop_at; i++)
  {
    if (!this.particles[i].IsAlive ())
    {
      return !this.EmitParticleIndex (i);
    }
  }

  // FIX-ME: if we get here we need to do some sort of cooldown
  // the issue is we are emitting too many particles per total particle count
  // along with particles that have a too big life
  return true; // indicates something is wrong
}

// Emit particles from the emitter (Should we return failure to the caller?)
void Emitter::Emit ()
{
  for (int i = 0; i < this.emitCount; i++)
  {
    // if it failed to emit with either don't have more overlays or particles, so we return
    // TODO: do some kind of cooldown in the emitter here.
    if (this.EmitSingleParticle ())
      return;
  }
}

// Update all particles
void Emitter::Update ()
{
  for (int i = 0; i < this.maxParticles; i++)
  {
    if (this.particles[i].life > 0)
    {
      this.particles[i]._Update ();
    }
    else if (this.particles[i].overlayIndex >= 0)
    {
      this.particles[i].overlayIndex
          = FreeOverlay (this.particles[i].overlayIndex);
    }
  }
}

Particle *[] Emitter::ParticlesHitPoint (int x, int y)
{
  int c[] = new int[this.maxParticles];
  int c_count;
  for (int i = 0; i < this.maxParticles; i++)
  {
    Particle *p = this.particles[i];
    if (p.IsAlive () && p.HitsPoint (x, y))
    {
      c[c_count] = i;
      c_count++;
    }
  }
  Particle *ps[] = new Particle[c_count + 1];
  for (int i = 0; i < c_count; i++)
  {
    ps[i] = this.particles[c[i]];
  }
  return ps;
}

Particle *[] Emitter::ParticlesHitRect (int x, int y, int width, int height) 
{
  int c[] = new int[this.maxParticles];
  int c_count = 0;
  for (int i = 0; i < this.maxParticles; i++)
  {
    Particle *p = this.particles[i];
    if (p.IsAlive () && p.HitsRect (x, y, width, height))
    {
      c[c_count] = i;
      c_count++;
    }
  }
  Particle *ps[] = new Particle[c_count + 1];
  for (int i = 0; i < c_count; i++)
  {
    ps[i] = this.particles[c[i]];
  }
  return ps;
}

void ContinuousEmitter::StartEmitting (int emitInterval)
{
  if (emitInterval < 4)
    emitInterval = 4;
  this.emitInterval = emitInterval;
  this.isEmitting = true;
}

void ContinuousEmitter::StopEmitting ()
{
  this.isEmitting = false;
}

void ContinuousEmitter::UpdateContinuous ()
{
  this.Update ();
  if (this.isEmitting)
  {
    this._emitCooldown--;
    if (this._emitCooldown <= 0)
    {
      this._emitCooldown = this.emitInterval;
      this.Emit ();
    }
  }
}

// --- Global Particle Emitter for easy quick particle emission

ContinuousEmitter GPE;
export GPE;

void game_start ()
{
  ParticleDefinition *d[];
  int max_particles =  MAX_OVERLAYS; // (MAX_OVERLAYS * 4) / 5;
  int emit_count = max_particles / 16;
  GPE.Init (Screen.Width / 2, Screen.Height / 2, d, 0, emit_count,  max_particles);
}

void repeatedly_execute_always ()
{
  GPE.UpdateContinuous ();
}