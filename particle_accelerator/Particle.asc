// Particle Accelerator module script

#define LERP_SCALE 1024
#define INT_FRAC 1024
#define MAX_OVERLAYS 2048
Overlay *overlayPool[MAX_OVERLAYS];
bool overlayUsed[MAX_OVERLAYS];
int lastUsed;

int FreeOverlay (int index)
{
  if (overlayPool[index] != null)
  {
    overlayPool[index].Transparency = 100;
  }
  overlayUsed[index] = false; // Mark the overlay slot as free
  return -1;
}

// Find an available overlay slot in the pool, remember the slot to speed up search
int FindFreeOverlaySlot ()
{
  for (int i = lastUsed + 1; i < MAX_OVERLAYS; i++)
  {
    if (!overlayUsed[i])
    {
      overlayUsed[i] = true;
      lastUsed = i;
      return i;
    }
  }
  for (int i = 0; i < lastUsed; i++)
  {
    if (!overlayUsed[i])
    {
      overlayUsed[i] = true;
      lastUsed = i;
      return i;
    }
  }
  return -1; // No available overlay
}

// ---------------------- Particle methods ----------------------------

// we will use extenders in internal methods
void _SyncOverlay (this Particle*, Overlay* ovr)
{
  ovr.Transparency = this.Transparency;
  ovr.Graphic = this.Sprite;
#ifdef SCRIPT_API_v362
  ovr.SetPosition (this.X, this.Y, this.Width, this.Height);
#else
  ovr.X = this.X;
  ovr.Y = this.Y;
  ovr.Width = this.Width;
  ovr.Height = this.Height;
#endif
#ifdef SCRIPT_API_v400
  ovr.Rotation = this.Angle;
#endif
}

void _Init (this Particle*, ParticleDefinition *def, int x, int y, Overlay* ovr)
{
  this.MiliX = INT_FRAC * (x + def.OffsetX); // Offset based on emitter
  this.MiliY = INT_FRAC * (y + def.OffsetY); // Offset based on emitter
  this.X = this.MiliX / INT_FRAC;
  this.Y = this.MiliY / INT_FRAC;
  this._Life = def.LifeTotal;
  this.VelX = (def.VelX * INT_FRAC) / 1000;
  this.VelY = (def.VelY * INT_FRAC) / 1000;
  this.Gravity = (def.Gravity * INT_FRAC) / 1000;

  this.Transparency = def.TransparencyBegin;
  this.TransparencyBegin = def.TransparencyBegin;
  this.TransparencyDelta = def.TransparencyEnd - def.TransparencyBegin;

  this.Width = def.WidthBegin;
  this.WidthBegin = def.WidthBegin;
  this.WidthDelta = def.WidthEnd - def.WidthBegin;

  this.Height = def.HeightBegin;
  this.HeightBegin = def.HeightBegin;
  this.HeightDelta = def.HeightEnd - def.HeightBegin;

  this.SpriteCycleOffset = def.Sprite - def.SpriteBegin;
  this.Sprite = def.Sprite;
  this.SpriteBegin = def.SpriteBegin;
  this.SpriteDelta = def.SpriteEnd - def.SpriteBegin;
  
#ifdef SCRIPT_API_v400
  this.RotationSpeed = def.RotationSpeed;
  this.Angle = def.Angle;
#endif

  this.InitialLife = def.LifeTotal; // Store initial life for transitions
  this.Bounces = def.Bounces;
  this.GroundY = def.GroundY;
  if (this.GroundY <= 0)
  {
    this.GroundY = 16777216; // a big number so it is not reached
  }
  
#ifdef SCRIPT_API_v400
  ovr.BlendMode = def.BlendMode;
#endif
  this._SyncOverlay(ovr);
}

// Update the particle state and sync with overlay
void _Update (this Particle*)
{
  // alive check is done before calling this function
  this.MiliX += this.VelX;
  this.MiliY += this.VelY;
  this.VelY += this.Gravity; // Apply Gravity
  this.X = this.MiliX / INT_FRAC;
  this.Y = this.MiliY / INT_FRAC;

  // Calculate the scaling and Transparency transitions based on life
  int percent = LERP_SCALE - ((this._Life * LERP_SCALE) / this.InitialLife); // 0 to 1024
  this.Transparency = this.TransparencyBegin + ((this.TransparencyDelta) * percent) / LERP_SCALE;
  this.Width = this.WidthBegin + ((this.WidthDelta) * percent) / LERP_SCALE;
  this.Height = this.HeightBegin + ((this.HeightDelta) * percent) / LERP_SCALE;
  if (this.SpriteDelta > 0)
  {
    this.Sprite
        = this.SpriteBegin
          + (this.SpriteCycleOffset + ((this.SpriteDelta) * percent) / LERP_SCALE)
                % this.SpriteDelta;
  }
  
#ifdef SCRIPT_API_v400
  this.Angle += this.RotationSpeed;
  if (this.Angle >= 360.0)
    this.Angle -= 360.0;
  if (this.Angle < 0.0)
    this.Angle += 360.0;
#endif

  int oidx = this._OverlayIdx;
  if (oidx >= 0 && overlayPool[oidx] != null)
  {
    Overlay *ovr = overlayPool[oidx];
    ovr.Transparency = this.Transparency;
    ovr.Graphic = this.Sprite;
#ifdef SCRIPT_API_v362
    ovr.SetPosition (this.X, this.Y, this.Width, this.Height);
#else
    ovr.X = this.X;
    ovr.Y = this.Y;
    ovr.Width = this.Width;
    ovr.Height = this.Height;
#endif
#ifdef SCRIPT_API_v400
    ovr.Rotation = this.Angle;
#endif
  }

  this._Life--;

  if (this.Y >= this.GroundY)
  {
    if (this.Bounces)
    {
      this.VelY = -(this.VelY * 700) / INT_FRAC; // Invert velocity and simulate energy loss
    }
    else
    {
      this._Life = 0; // Mark particle as dead (cheaper than other things...)
    }
  }
}

int get_Life(this Particle*)
{
  return this._Life;
}

void set_Life(this Particle*, int value)
{
  this._Life = value;
}

bool Particle::IsAlive ()
{
  return (this._Life > 0);
}

bool Particle::HitsPoint (int x, int y)
{
  return (x >= this.X) && (y >= this.Y)
         && (x <= this.X + this.Width) && (y <= this.Y + this.Height);
}

bool Particle::HitsRect (int x, int y, int width, int height)
{
  return (x + width >= this.X) && (y + height >= this.Y)
         && (x <= this.X + this.Width) && (y <= this.Y + this.Height);
}



// ---------------------- Emitter methods ----------------------------

void Emitter::SetPosition (int x, int y)
{
  this.X = x;
  this.Y = y;
}

void Emitter::SetParticleDefinitions (ParticleDefinition *defs[], int defCount)
{
  for (int i = 0; i < defCount; i++)
  {
    ParticleDefinition *def = defs[i];
    if (def.SpriteBegin == 0 && def.SpriteEnd == 0)
    {
      def.SpriteBegin = def.Sprite;
      def.SpriteEnd = def.Sprite;
    }
  }

  this.definitions = defs;
  this.definitionsCount = defCount;
}

// Initialize the emitter with position, particle definitions, and other parameters
void Emitter::Init (int x, int y, ParticleDefinition *defs[], int defCount, int emitAmount, int maxParticles)
{
  this.SetPosition (x, y);
  this.maxParticles = maxParticles;
  this.SetParticleDefinitions (defs, defCount);
  this.EmitAmount = emitAmount;
  this.particles = new Particle[maxParticles];
  for (int i = 0; i < maxParticles; i++)
  {
    this.particles[i] = new Particle;
  }
}

// returns TRUE if it emitted the particle SUCCESSFULLY
protected bool Emitter::_EmitParticleIndex (int i)
{
  Particle *p = this.particles[i];
  if (p.IsAlive ())
    return false;
    
  // Reuse dead particle if it's not alive anymore

  this.lastEmittedParticle = i; // remember to speed up loop for looking new particles
  int overlayIndex = FindFreeOverlaySlot ();
  if (overlayIndex >= 0)
  {
    // Randomly select a particle definition from the available definitions
    int defIndex = 0;
    if (this.definitionsCount > 0)
    {
      defIndex = Random (this.definitionsCount - 1);
    }
    ParticleDefinition *def = this.definitions[defIndex];

    if(p._OverlayIdx >= 0) {
      FreeOverlay(p._OverlayIdx);
    }
    if (overlayPool[overlayIndex] == null)
    {
      Overlay *ovr = Overlay.CreateGraphical (this.X, this.Y, def.Sprite);
      overlayPool[overlayIndex] = ovr;
    }
    p._Init (def, this.X, this.Y, overlayPool[overlayIndex]);
    p._OverlayIdx = overlayIndex;
    return true;
  }
  return false;
}

// Emit a single particle from the emitter, returns TRUE for FAILURE
protected bool Emitter::_EmitSingleParticle ()
{
  int i = (this.lastEmittedParticle + 1) % this.maxParticles;

  if (this._EmitParticleIndex (i)) // if it fail to emit, try to find a dead particle to reuse
    return false;

  int loop_at = i;
  for (; i < this.maxParticles; i++)
  {
    if (!this.particles[i].IsAlive ())
    {
      return !this._EmitParticleIndex (i);
    }
  }

  for (i = 0; i < loop_at; i++)
  {
    if (!this.particles[i].IsAlive ())
    {
      return !this._EmitParticleIndex (i);
    }
  }

  return true; // indicates something is wrong
}

// Emit particles from the emitter, returns true on success
bool Emitter::Emit ()
{
  for (int i = 0; i < this.EmitAmount; i++)
  {
    // if we either don't have more overlays or particles, return failure
    if (this._EmitSingleParticle ())
      return false;
  }
  return true;
}

// Update all particles
void Emitter::Update ()
{
  for (int i = 0; i < this.maxParticles; i++)
  {
    if (this.particles[i]._Life > 0)
    {
      this.particles[i]._Update ();
    }
    else if (this.particles[i]._OverlayIdx >= 0)
    {
      this.particles[i]._OverlayIdx = FreeOverlay (this.particles[i]._OverlayIdx);
    }
  }
}

Particle *[] Emitter::ParticlesHitPoint (int x, int y)
{
  int c[] = new int[this.maxParticles];
  int c_count;
  for (int i = 0; i < this.maxParticles; i++)
  {
    Particle *p = this.particles[i];
    if (p.IsAlive () && p.HitsPoint (x, y))
    {
      c[c_count] = i;
      c_count++;
    }
  }
  Particle *ps[] = new Particle[c_count + 1];
  for (int i = 0; i < c_count; i++)
  {
    ps[i] = this.particles[c[i]];
  }
  return ps;
}

Particle *[] Emitter::ParticlesHitRect (int x, int y, int width, int height) 
{
  int c[] = new int[this.maxParticles];
  int c_count = 0;
  for (int i = 0; i < this.maxParticles; i++)
  {
    Particle *p = this.particles[i];
    if (p.IsAlive () && p.HitsRect (x, y, width, height))
    {
      c[c_count] = i;
      c_count++;
    }
  }
  Particle *ps[] = new Particle[c_count + 1];
  for (int i = 0; i < c_count; i++)
  {
    ps[i] = this.particles[c[i]];
  }
  return ps;
}

void ContinuousEmitter::StartEmitting (int emitInterval)
{
  if (emitInterval < 4)
    emitInterval = 4;
  this.emitInterval = emitInterval;
  this.isEmitting = true;
}

void ContinuousEmitter::StopEmitting ()
{
  this.isEmitting = false;
}

void ContinuousEmitter::UpdateContinuous ()
{
  this.Update ();
  
  if (!this.isEmitting) return;
  
  this._emitCooldown--;
  if (this._emitCooldown <= 0)
  {
    bool success = this.Emit ();
    this._emitCooldown = this.emitInterval;
    
    // if we fail to emit we need to increase cooldown
    // we are emitting too many long lived particles per total particle count
    // TODO: test and actually evaluate if this does anything to help
    if(!success) // failed to emit,  increase interval
      this._emitCooldown+=2;
  }
}

// --- Global Particle Emitter for easy quick particle emission

ContinuousEmitter GPE;
export GPE;

void game_start ()
{
  ParticleDefinition *d[];
  int max_particles =  MAX_OVERLAYS; // (MAX_OVERLAYS * 4) / 5;
  int emit_count = max_particles / 16;
  GPE.Init (Screen.Width / 2, Screen.Height / 2, d, 0, emit_count,  max_particles);
}

void repeatedly_execute_always ()
{
  GPE.UpdateContinuous ();
}