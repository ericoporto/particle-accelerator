// new module script

#define MAX_OVERLAYS 512
Overlay* overlayPool[MAX_OVERLAYS];
bool overlayUsed[MAX_OVERLAYS];
int lastUsed;
Emitter GPE;
export GPE;

#define MAX_LERP 1024

// lerp from percent 0 to 1024
int _Lerp(int start, int end, int percent) {
  if (percent < 0) percent = 0;
  if (percent > MAX_LERP) percent = MAX_LERP;

  // Calculate the interpolated value
  return start + ((end - start) * percent) / MAX_LERP;
}

int InvalidateOverlay(int index)
{
  if(overlayPool[index] != null)
    overlayPool[index].Remove();
  overlayPool[index] = null; // Clear the reference to the overlay
  overlayUsed[index] = false; // Mark the overlay slot as free
  return -1;
}

// Find an available overlay slot in the pool
function GetAvailableOverlayIndex() {
  for (int i = lastUsed; i < MAX_OVERLAYS; i++) {
    if (!overlayUsed[i]) {
      InvalidateOverlay(i);
      overlayUsed[i] = true;
      lastUsed = i;
      return i;
    }
  }
  for (int i = 0; (i < lastUsed) && (i < MAX_OVERLAYS); i++) {
    if (!overlayUsed[i]) {
      InvalidateOverlay(i);
      overlayUsed[i] = true;
      lastUsed = i;
      return i;
    }
  }
  return -1; // No available overlay
}

void UpdateOverlayFromParticle(Overlay* ovr, Particle* p)
{
  ovr.X = FloatToInt(p.x);
  ovr.Y = FloatToInt(p.y);
  ovr.Transparency = p.transparency;
  ovr.Width = p.width;
  ovr.Height = p.height;
}

void Particle::Init(ParticleDefinition* def, int x, int y,  int overlayIndex) {
  if(this.overlayIndex >= 0 && this.overlayIndex < MAX_OVERLAYS) {
    InvalidateOverlay(this.overlayIndex);
  }

  this.x = IntToFloat(x + def.offsetX); // Offset based on emitter
  this.y = IntToFloat(y + def.offsetY); // Offset based on emitter
  this.life = def.life;
  this.vx = IntToFloat(def.vx)/1000.0;
  this.vy = IntToFloat(def.vy)/1000.0;
  this.gravity = IntToFloat(def.gravity)/1000.0;
  this.transparency = def.initialTransparency;
  this.initialTransparency = def.initialTransparency;
  this.finalTransparency = def.finalTransparency;
  this.width = def.initialWidth;
  this.initialWidth = def.initialWidth;
  this.finalWidth = def.finalWidth;
  this.height = def.initialHeight;
  this.initialHeight = def.initialHeight;
  this.finalHeight = def.finalHeight;
  this.overlayIndex = overlayIndex;
  this.initialLife = def.life; // Store initial life for transitions

  if (overlayIndex >= 0 && overlayPool[overlayIndex] != null) {
    UpdateOverlayFromParticle(overlayPool[overlayIndex], this);
  }
}

bool Particle::IsAlive() {
  return (this.life > 0);
}

// Update the particle state and sync with overlay
void Particle::Update() {
  if (this.IsAlive()) {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += this.gravity; // Apply gravity
    this.life--;

    // Calculate the scaling and transparency transitions based on life
    int lifeRatio =  MAX_LERP - ((this.life * MAX_LERP) / this.initialLife); // 0 to 1024
    this.transparency = _Lerp(this.initialTransparency, this.finalTransparency, lifeRatio);
    this.width = _Lerp(this.initialWidth, this.finalWidth, lifeRatio);
    this.height = _Lerp(this.initialHeight, this.finalHeight, lifeRatio);

    if (this.overlayIndex >= 0 && overlayPool[this.overlayIndex] != null) {
      UpdateOverlayFromParticle(overlayPool[this.overlayIndex], this);
    }
  } else {
    // Remove overlay if life is over
    if (this.overlayIndex >= 0) {
      this.overlayIndex = InvalidateOverlay(this.overlayIndex); // Invalidate the overlay index
    }
  }
}

void Emitter::SetPosition(int x, int y)
{
  this.x = x;
  this.y = y;
}

void Emitter::SetSprite(int graphic)
{
  this.sprite = graphic;
}

void Emitter::SetParticleDefinitions(ParticleDefinition* definitions[], int definitionsCount)
{
  this.definitions = definitions;
  this.definitionsCount = definitionsCount;
}

// Initialize the emitter with position, particle definitions, and specific parameters
void Emitter::Init(int x, int y, ParticleDefinition* definitions[], int definitionsCount, int emitParticleCount, int particleCount, int sprite, int gravity) {
  this.SetPosition(x, y);
  this.particleCount = particleCount;
  this.SetSprite(sprite);
  this.gravity = gravity;
  this.SetParticleDefinitions(definitions, definitionsCount);
  this.emitParticleCount = emitParticleCount;
  this.particles = new Particle[particleCount];
  for (int i = 0; i < particleCount; i++) {
    this.particles[i] = new Particle;
  }
}

// Emit a single particle from the emitter
void Emitter::EmitSingleParticle() {
  for (int i = 0; i < this.particleCount; i++) {
    if (this.particles[i].IsAlive())
    {
      continue;
    }
    
    // Reuse dead particle if it's not alive anymore
    int overlayIndex = GetAvailableOverlayIndex();
    if (overlayIndex >= 0) {
      Overlay* ovr = Overlay.CreateGraphical(this.x, this.y, this.sprite);
      overlayPool[overlayIndex] = ovr;

      // Randomly select a particle definition from the available definitions
      int defIndex = 0;
      if(this.definitionsCount > 0) {
        defIndex = Random(this.definitionsCount-1);
      }
      ParticleDefinition* def = this.definitions[defIndex];

      this.particles[i].Init(def, this.x, this.y, overlayIndex);
    }
    return;
  }
}

// Emit particles from the emitter
void Emitter::Emit() {
  for (int i = 0; i < this.emitParticleCount; i++) {
    this.EmitSingleParticle();
  }
}

// Update all particles
void Emitter::Update() {
  for (int i = 0; i < this.particleCount; i++) {
    if (this.particles[i].IsAlive()) {
      this.particles[i].Update();
    } else if (this.particles[i].overlayIndex >= 0) {
      // Ensure overlays are freed for dead particles
      this.particles[i].overlayIndex = InvalidateOverlay(this.particles[i].overlayIndex); // Invalidate the overlay index
    }
  }
}

void game_start()
{
  ParticleDefinition* d[];
  GPE.Init(Screen.Width/2, Screen.Height/2, d, 0, 20, 80, 0, 0);
}

void repeatedly_execute_always()
{
  GPE.Update();
}
