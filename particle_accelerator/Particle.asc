// new module script

#define MAX_LERP 1024
#define INT_FRAC 1024
#define MAX_OVERLAYS 2048
Overlay *overlayPool[MAX_OVERLAYS];
bool overlayUsed[MAX_OVERLAYS];
int lastUsed;


int InvalidateOverlay (int index)
{
  if (overlayPool[index] != null)
  {
    overlayPool[index].Transparency = 100;
  }
  overlayUsed[index] = false; // Mark the overlay slot as free
  return -1;
}

// Find an available overlay slot in the pool
int GetAvailableOverlayIndex ()
{
  for (int i = lastUsed; i < MAX_OVERLAYS; i++)
  {
    if (!overlayUsed[i])
    {
      overlayUsed[i] = true;
      lastUsed = i;
      return i;
    }
  }
  for (int i = 0; i < lastUsed; i++)
  {
    if (!overlayUsed[i])
    {
      overlayUsed[i] = true;
      lastUsed = i;
      return i;
    }
  }
  return -1; // No available overlay
}

void UpdateOverlayFromParticle (Overlay *ovr, Particle *p)
{
  ovr.Transparency = p.transparency;
  ovr.Graphic = p.sprite;
#ifdef SCRIPT_API_v362
  ovr.SetPosition (p.x, p.y, p.width, p.height);
#else
  ovr.X = p.x;
  ovr.Y = p.y;
  ovr.Width = p.width;
  ovr.Height = p.height;
#endif
}



bool Particle::IsAlive ()
{
  return (this.life > 0);
}

bool Particle::HitsPoint (int x, int y)
{
  return (x >= this.x) && (y >= this.y) && (x <= this.x + this.width)
         && (y <= this.y + this.height);
}

bool Particle::HitsRect (int x, int y, int width, int height)
{
  return (x + width >= this.x) && (y + height >= this.y)
         && (x <= this.x + this.width) && (y <= this.y + this.height);
}

void Particle::_Init (ParticleDefinition *def, int x, int y, int overlayIndex)
{
  if (this.overlayIndex >= 0 && this.overlayIndex < MAX_OVERLAYS)
  {
    InvalidateOverlay (this.overlayIndex);
  }

  this.mx = INT_FRAC * (x + def.offsetX); // Offset based on emitter
  this.my = INT_FRAC * (y + def.offsetY); // Offset based on emitter
  this.x = this.mx / INT_FRAC;
  this.y = this.my / INT_FRAC;
  this.life = def.life;
  this.vx = (def.vx * INT_FRAC) / 1000;
  this.vy = (def.vy * INT_FRAC) / 1000;
  this.gravity = (def.gravity * INT_FRAC) / 1000;

  this.transparency = def.initialTransparency;
  this.initialTransparency = def.initialTransparency;
  this.deltaTransparency = def.finalTransparency - def.initialTransparency;

  this.width = def.initialWidth;
  this.initialWidth = def.initialWidth;
  this.deltaWidth = def.finalWidth - def.initialWidth;

  this.height = def.initialHeight;
  this.initialHeight = def.initialHeight;
  this.deltaHeight = def.finalHeight - def.initialHeight;

  this.rollSprite = def.sprite - def.initialSprite;
  this.sprite = def.sprite;
  this.initialSprite = def.initialSprite;
  this.deltaSprite = def.finalSprite - def.initialSprite;

  this.overlayIndex = overlayIndex;
  this.initialLife = def.life; // Store initial life for transitions
  this.bounces = def.groundHitBounces;
  this.groundY = def.groundY;
  if (this.groundY <= 0)
  {
    this.groundY = 16777216; // a big number so it is not reached
  }

  if (overlayIndex >= 0 && overlayPool[overlayIndex] != null)
  {
    Overlay *ovr = overlayPool[overlayIndex];
    UpdateOverlayFromParticle (ovr, this);
#ifdef SCRIPT_API_v400
    ovr.BlendMode = def.BlendMode;
    this.rotationSpeed = def.rotationSpeed;
    this.angle = def.angle;
    ovr.Rotation = this.angle;
#endif
  }
}

// Update the particle state and sync with overlay
void Particle::_Update ()
{
  // alive check is done before calling this function
  this.mx += this.vx;
  this.my += this.vy;
  this.vy += this.gravity; // Apply gravity
  this.x = this.mx / INT_FRAC;
  this.y = this.my / INT_FRAC;

  // Calculate the scaling and transparency transitions based on life
  int percent
      = MAX_LERP - ((this.life * MAX_LERP) / this.initialLife); // 0 to 1024
  this.transparency = this.initialTransparency
                      + ((this.deltaTransparency) * percent) / MAX_LERP;
  this.width = this.initialWidth + ((this.deltaWidth) * percent) / MAX_LERP;
  this.height = this.initialHeight + ((this.deltaHeight) * percent) / MAX_LERP;
  if (this.deltaSprite > 0)
  {
    this.sprite
        = this.initialSprite
          + (this.rollSprite + ((this.deltaSprite) * percent) / MAX_LERP)
                % this.deltaSprite;
  }

  int oidx = this.overlayIndex;
  if (oidx >= 0 && overlayPool[oidx] != null)
  {
    // UpdateOverlayFromParticle(overlayPool[this.overlayIndex], this);
    Overlay *ovr = overlayPool[oidx];
    ovr.Transparency = this.transparency;
    ovr.Graphic = this.sprite;
#ifdef SCRIPT_API_v362
    ovr.SetPosition (this.x, this.y, this.width, this.height);
#else
    ovr.X = this.x;
    ovr.Y = this.y;
    ovr.Width = this.width;
    ovr.Height = this.height;
#endif
#ifdef SCRIPT_API_v400
    this.angle += this.rotationSpeed;
    if (this.angle >= 360.0)
      this.angle -= 360.0;
    if (this.angle < 0.0)
      this.angle += 360.0;
    float angle = this.angle;
    ovr.Rotation = this.angle;
#endif
  }

  this.life--;

  if (this.y >= this.groundY)
  {
    if (this.bounces)
    {
      this.vy = -(this.vy * 700) / INT_FRAC; // Invert velocity, reduce it
                                             // to simulate energy loss
    }
    else
    {
      this.life = 0; // Mark particle as dead (cheaper than other things...)
    }
  }
}

void Emitter::SetPosition (int x, int y)
{
  this.x = x;
  this.y = y;
}

void Emitter::SetParticleDefinitions (ParticleDefinition *defs[], int defCount)
{
  for (int i = 0; i < defCount; i++)
  {
    ParticleDefinition *def = defs[i];
    if (def.initialSprite == 0 && def.finalSprite == 0)
    {
      def.initialSprite = def.sprite;
      def.finalSprite = def.sprite;
    }
  }

  this.definitions = defs;
  this.definitionsCount = defCount;
}

// Initialize the emitter with position, particle definitions, and specific
// parameters
void Emitter::Init (int x, int y, ParticleDefinition *defs[], int defCount, int emitCount, int maxParticles)
{
  this.SetPosition (x, y);
  this.maxParticles = maxParticles;
  this.SetParticleDefinitions (defs, defCount);
  this.emitCount = emitCount;
  this.particles = new Particle[maxParticles];
  for (int i = 0; i < maxParticles; i++)
  {
    this.particles[i] = new Particle;
  }
}

protected bool Emitter::EmitParticleIndex (int i)
{
  if (this.particles[i].IsAlive ())
    return false;

  this.lastEmittedParticle = i;

  // Reuse dead particle if it's not alive anymore
  int overlayIndex = GetAvailableOverlayIndex ();
  if (overlayIndex >= 0)
  {
    // Randomly select a particle definition from the available definitions
    int defIndex = 0;
    if (this.definitionsCount > 0)
    {
      defIndex = Random (this.definitionsCount - 1);
    }
    ParticleDefinition *def = this.definitions[defIndex];

    if (overlayPool[overlayIndex] == null)
    {
      Overlay *ovr = Overlay.CreateGraphical (this.x, this.y, def.sprite);
      overlayPool[overlayIndex] = ovr;
    }
    this.particles[i]._Init (def, this.x, this.y, overlayIndex);
  }
  return true;
}

// Emit a single particle from the emitter
protected bool Emitter::EmitSingleParticle ()
{
  // System.Log(eLogInfo, ">>begin sp");
  int i = (this.lastEmittedParticle + 1) % this.maxParticles;

  if (this.EmitParticleIndex (i))
    return false;

  // System.Log(eLogInfo, "loop1 sp");
  int loop_at = i;
  for (; i < this.maxParticles; i++)
  {
    if (!this.particles[i].IsAlive ())
    {
      this.EmitParticleIndex (i);
      return false;
    }
  }

  // System.Log(eLogInfo, "loop2 sp");
  for (i = 0; i < loop_at; i++)
  {
    if (!this.particles[i].IsAlive ())
    {
      this.EmitParticleIndex (i);
      return false;
    }
  }

  // FIX-ME: if we get here we need to do some sort of cooldown
  // the issue is we are emitting too many particles per total particle count
  // along with particles that have a too big life
  return true; // indicates something is wrong
}

// Emit particles from the emitter
void Emitter::Emit ()
{
  for (int i = 0; i < this.emitCount; i++)
  {
    if (this.EmitSingleParticle ())
      return;
  }
}

// Update all particles
void Emitter::Update ()
{
  for (int i = 0; i < this.maxParticles; i++)
  {
    if (this.particles[i].life > 0)
    {
      this.particles[i]._Update ();
    }
    else if (this.particles[i].overlayIndex >= 0)
    {
      this.particles[i].overlayIndex
          = InvalidateOverlay (this.particles[i].overlayIndex);
    }
  }
}

Particle *[] Emitter::ParticlesHitPoint (int x, int y)
{
  int c[] = new int[this.maxParticles];
  int c_count;
  for (int i = 0; i < this.maxParticles; i++)
  {
    Particle *p = this.particles[i];
    if (p.IsAlive () && p.HitsPoint (x, y))
    {
      c[c_count] = i;
      c_count++;
    }
  }
  Particle *ps[] = new Particle[c_count + 1];
  for (int i = 0; i < c_count; i++)
  {
    ps[i] = this.particles[c[i]];
  }
  return ps;
}

Particle *[] Emitter::ParticlesHitRect (int x, int y, int width, int height) 
{
  int c[] = new int[this.maxParticles];
  int c_count = 0;
  for (int i = 0; i < this.maxParticles; i++)
  {
    Particle *p = this.particles[i];
    if (p.IsAlive () && p.HitsRect (x, y, width, height))
    {
      c[c_count] = i;
      c_count++;
    }
  }
  Particle *ps[] = new Particle[c_count + 1];
  for (int i = 0; i < c_count; i++)
  {
    ps[i] = this.particles[c[i]];
  }
  return ps;
}

void ContinuousEmitter::StartEmitting (int emitRate)
{
  if (emitRate < 4)
    emitRate = 4;
  this.emitRate = emitRate;
  this.isEmitting = true;
}

void ContinuousEmitter::StopEmitting ()
{
  this.isEmitting = false;
}

void ContinuousEmitter::UpdateContinuous ()
{
  this.Update ();
  if (this.isEmitting)
  {
    this._emitRateFrame--;
    if (this._emitRateFrame <= 0)
    {
      this._emitRateFrame = this.emitRate;
      this.Emit ();
    }
  }
}

ContinuousEmitter GPE;
export GPE;

void game_start ()
{
  ParticleDefinition *d[];
  int max_particles = (MAX_OVERLAYS * 4) / 5;
  GPE.Init (Screen.Width / 2, Screen.Height / 2, d, 0, max_particles / 16,
            max_particles);
}

void repeatedly_execute_always ()
{
  GPE.UpdateContinuous ();
}