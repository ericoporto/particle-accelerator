// new module script

#define MAX_OVERLAYS 2048
Overlay* overlayPool[MAX_OVERLAYS];
bool overlayUsed[MAX_OVERLAYS];
int lastUsed;

#define MAX_LERP 1024
#define INT_FRAC 1024

// lerp from percent 0 to 1024
int _Lerp(int start, int end, int percent) {
  if (percent < 0) percent = 0;
  if (percent > MAX_LERP) percent = MAX_LERP;
  return start + ((end - start) * percent) / MAX_LERP;
}

int InvalidateOverlay(int index)
{
  if(overlayPool[index] != null)
  {
    overlayPool[index].Transparency = 100;
  }
  overlayUsed[index] = false; // Mark the overlay slot as free
  return -1;
}

// Find an available overlay slot in the pool
function GetAvailableOverlayIndex() {
  for (int i = lastUsed; i < MAX_OVERLAYS; i++) {
    if (!overlayUsed[i]) {
      overlayUsed[i] = true;
      lastUsed = i;
      return i;
    }
  }
  for (int i = 0; i < lastUsed; i++) {
    if (!overlayUsed[i]) {
      overlayUsed[i] = true;
      lastUsed = i;
      return i;
    }
  }
  return -1; // No available overlay
}

void UpdateOverlayFromParticle(Overlay* ovr, Particle* p)
{
  ovr.Transparency = p.transparency;
  ovr.Graphic = p.sprite;
#ifdef SCRIPT_API_v362
  ovr.SetPosition(p.x/INT_FRAC, p.y/INT_FRAC, p.width, p.height);
#else
  ovr.X = p.x/INT_FRAC;
  ovr.Y = p.y/INT_FRAC;
  ovr.Width = p.width;
  ovr.Height = p.height;
#endif
}

void Particle::Init(ParticleDefinition* def, int x, int y,  int overlayIndex) {
  if(this.overlayIndex >= 0 && this.overlayIndex < MAX_OVERLAYS) {
    InvalidateOverlay(this.overlayIndex);
  }

  this.x = INT_FRAC*(x + def.offsetX); // Offset based on emitter
  this.y = INT_FRAC*(y + def.offsetY); // Offset based on emitter
  this.life = def.life;
  this.vx = (def.vx*INT_FRAC)/1000;
  this.vy = (def.vy*INT_FRAC)/1000;
  this.gravity = (def.gravity*INT_FRAC)/1000;
  
  this.transparency = def.initialTransparency;
  this.initialTransparency = def.initialTransparency;
  this.deltaTransparency = def.finalTransparency - def.initialTransparency;
  
  this.width = def.initialWidth;
  this.initialWidth = def.initialWidth;
  this.deltaWidth = def.finalWidth - def.initialWidth;
  
  this.height = def.initialHeight;
  this.initialHeight = def.initialHeight;
  this.deltaHeight = def.finalHeight - def.initialHeight;
  
  this.rollSprite = def.sprite - def.initialSprite;
  this.sprite = def.sprite;
  this.initialSprite = def.initialSprite;
  this.deltaSprite = def.finalSprite - def.initialSprite;
  
  this.overlayIndex = overlayIndex;
  this.initialLife = def.life; // Store initial life for transitions
  this.bounces = def.groundHitBounces;
  this.groundY = def.groundY*INT_FRAC;
  if(this.groundY <= 0) {
    this.groundY = 16777216; // a big number so it is not reached
  }

  if (overlayIndex >= 0 && overlayPool[overlayIndex] != null) {
    UpdateOverlayFromParticle(overlayPool[overlayIndex], this);
  }
}

bool Particle::IsAlive() {
  return (this.life > 0);
}

// Update the particle state and sync with overlay
void Particle::Update() {
  // alive check is done before calling this function
  this.x += this.vx;
  this.y += this.vy;
  this.vy += this.gravity; // Apply gravity
  int px = this.x/INT_FRAC;
  int py = this.y/INT_FRAC;

  // Calculate the scaling and transparency transitions based on life
  int percent =  MAX_LERP - ((this.life * MAX_LERP) / this.initialLife); // 0 to 1024  
  this.transparency = this.initialTransparency + ((this.deltaTransparency) * percent) / MAX_LERP;  
  this.width = this.initialWidth + ((this.deltaWidth) * percent) / MAX_LERP;
  this.height = this.initialHeight + ((this.deltaHeight) * percent) / MAX_LERP;
  if(this.deltaSprite > 0) {
    this.sprite = this.initialSprite + (this.rollSprite + ((this.deltaSprite) * percent) / MAX_LERP) % this.deltaSprite;
  }
  
  int oidx = this.overlayIndex;
  if (oidx >= 0 && overlayPool[oidx] != null) {
    // UpdateOverlayFromParticle(overlayPool[this.overlayIndex], this);
    Overlay* ovr = overlayPool[oidx];
    ovr.Transparency = this.transparency;
    ovr.Graphic = this.sprite;
#ifdef SCRIPT_API_v362
    ovr.SetPosition(px, py, this.width, this.height);
#else
    ovr.X = px;
    ovr.Y = py;
    ovr.Width = this.width;
    ovr.Height = this.height;
#endif
  }
  
  this.life--;
  
  if (this.y >= this.groundY) {
    if (this.bounces) {
      this.vy = -(this.vy * 700)/INT_FRAC; // Invert velocity, reduce it to simulate energy loss
    } else {
      this.life = 0; // Mark particle as dead (cheaper than other things...)
    }
  }
}

void Emitter::SetPosition(int x, int y)
{
  this.x = x;
  this.y = y;
}

void Emitter::SetParticleDefinitions(ParticleDefinition* definitions[], int definitionsCount)
{
  for(int i=0; i<definitionsCount; i++) {
    ParticleDefinition* def = definitions[i];
    if(def.initialSprite == 0 && def.finalSprite == 0) {
      def.initialSprite = def.sprite;
      def.finalSprite = def.sprite;
    }
  }
  
  this.definitions = definitions;
  this.definitionsCount = definitionsCount;
}

// Initialize the emitter with position, particle definitions, and specific parameters
void Emitter::Init(int x, int y, ParticleDefinition* definitions[], int definitionsCount, int emitParticleCount, int particleCount) {
  this.SetPosition(x, y);
  this.particleCount = particleCount;
  this.SetParticleDefinitions(definitions, definitionsCount);
  this.emitParticleCount = emitParticleCount;
  this.particles = new Particle[particleCount];
  for (int i = 0; i < particleCount; i++) {
    this.particles[i] = new Particle;
  }
}

protected bool Emitter::EmitParticleIndex(int i)
{
  if(this.particles[i].IsAlive())
    return false;

  this.lastEmittedParticle = i;
  
  // Reuse dead particle if it's not alive anymore
  int overlayIndex = GetAvailableOverlayIndex();
  if (overlayIndex >= 0) {      
    // Randomly select a particle definition from the available definitions
    int defIndex = 0;
    if(this.definitionsCount > 0) {
      defIndex = Random(this.definitionsCount-1);
    }
    ParticleDefinition* def = this.definitions[defIndex];
    
    if(overlayPool[overlayIndex] == null) {
      Overlay* ovr = Overlay.CreateGraphical(this.x, this.y, def.sprite);
      overlayPool[overlayIndex] = ovr;
    }
    this.particles[i].Init(def, this.x, this.y, overlayIndex);
  }
  return true;
}

// Emit a single particle from the emitter
protected bool Emitter::EmitSingleParticle() {
  //System.Log(eLogInfo, ">>begin sp");
  int i = (this.lastEmittedParticle + 1) % this.particleCount;
  
  if(this.EmitParticleIndex(i))
    return false;
  
  //System.Log(eLogInfo, "loop1 sp");
  int loop_at = i;
  for (; i < this.particleCount; i++) {
    if (!this.particles[i].IsAlive())
    {
      this.EmitParticleIndex(i);
      return false;
    }
  }
  
  //System.Log(eLogInfo, "loop2 sp");
  for (i=0; i < loop_at; i++) {
    if (!this.particles[i].IsAlive())
    {
      this.EmitParticleIndex(i);
      return false;
    }
  }
  
  // FIX-ME: if we get here we need to do some sort of cooldown 
  // the issue is we are emitting too many particles per total particle count
  // along with particles that have a too big life
  return true; // indicates something is wrong
}

// Emit particles from the emitter
void Emitter::Emit() {
  for (int i = 0; i < this.emitParticleCount; i++) {
    if(this.EmitSingleParticle())
      return;
  }
}

// Update all particles
void Emitter::Update() {
  for (int i = 0; i < this.particleCount; i++) {
    if (this.particles[i].life > 0) {
      this.particles[i].Update();
    } 
    else if (this.particles[i].overlayIndex >= 0) 
    {
      this.particles[i].overlayIndex = InvalidateOverlay(this.particles[i].overlayIndex);
    }
  }
}

void ContinuousEmitter::StartEmitting(int emitRate)
{
  if(emitRate < 4) emitRate = 4;
  this.emitRate = emitRate;
  this.isEmitting = true;
}

void ContinuousEmitter::StopEmitting()
{
  this.isEmitting = false; 
}

void ContinuousEmitter::UpdateContinuous()
{
  this.Update();
  if(this.isEmitting) {
    this._emitRateFrame--;    
    if(this._emitRateFrame <= 0) {
      this._emitRateFrame = this.emitRate;
      this.Emit();
    }
  } 
}
  
ContinuousEmitter GPE;
export GPE;

void game_start()
{
  ParticleDefinition* d[];
  int max_particles = (MAX_OVERLAYS*4)/5;
  GPE.Init(Screen.Width/2, Screen.Height/2, d, 0, max_particles/16, max_particles);
}

void repeatedly_execute_always()
{
  GPE.UpdateContinuous();
}
